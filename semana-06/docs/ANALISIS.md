# Análisis de Diseño - Semana 06

## Decisiones de Diseño

### Organización en Paquetes

**Paquete: abstractas/**  
[Justificación de por qué estas clases van aquí]

**Paquete: interfaces/**  
[Justificación]

**Paquete: implementaciones/**  
[Justificación]

---

## Clases Abstractas vs Interfaces

### ¿Cuándo usar Clase Abstracta?

[Explicación con ejemplos del proyecto]

**En este proyecto:**
- 

### ¿Cuándo usar Interface?

[Explicación con ejemplos del proyecto]

**En este proyecto:**
- 

---

## Interfaces Implementadas

### Interface: Reservable

**Propósito:**  
[Descripción]

**Métodos definidos:**
- 
- 

**Implementado por:**
- 
- 

---

### Interface: Evaluable

**Propósito:**  
[Descripción]

**Métodos definidos:**
- 
- 

**Implementado por:**
- 
- 

---

### Interface: Certifiable

**Propósito:**  
[Descripción]

**Métodos definidos:**
- 
- 

**Implementado por:**
- 
- 

---

## Principios SOLID Aplicados

### Single Responsibility Principle
[Cómo se aplicó]

### Open/Closed Principle
[Cómo se aplicó]

### Liskov Substitution Principle
[Cómo se aplicó]

### Interface Segregation Principle
[Cómo se aplicó]

### Dependency Inversion Principle
[Cómo se aplicó]

---

## Justificación de Interfaces

[Reflexión sobre por qué se eligieron estas interfaces y cómo mejoran el diseño del sistema]

